SHOW PDBS;
SHOW USER;
ALTER SESSION SET CONTAINER = XEPDB1;
SHOW CON_NAME;

BEGIN
    FOR t IN (SELECT table_name FROM user_tables 
              WHERE table_name IN ('EXAMRESULTS', 'EXAMS', 'REGISTER', 'COMPLETEDCOURSES', 
                                   'COURSES', 'PROFESSORS', 'STUDENTS', 'AUDITTRAIL', 
                                   'WARNINGS', 'DBUSERCREATIONLOG')) LOOP
        EXECUTE IMMEDIATE 'DROP TABLE ' || t.table_name || ' CASCADE CONSTRAINTS';
    END LOOP;
    
    FOR s IN (SELECT sequence_name FROM user_sequences 
              WHERE sequence_name IN ('WARNINGS_SEQ', 'AUDIT_SEQ', 'REGISTER_SEQ')) LOOP
        EXECUTE IMMEDIATE 'DROP SEQUENCE ' || s.sequence_name;
    END LOOP;
END;
/

CREATE TABLE Students (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    academic_status VARCHAR2(20) CHECK(academic_status IN ('Active', 'Suspended')),
    total_credits NUMBER DEFAULT 0
);

CREATE TABLE Professors (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    department VARCHAR2(100)
);

CREATE TABLE Courses (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    professor_id NUMBER,
    credit_hours NUMBER,
    prerequisite NUMBER,
    CONSTRAINT fk_course_professor FOREIGN KEY (professor_id) REFERENCES Professors(id),
    CONSTRAINT fk_course_prereq FOREIGN KEY (prerequisite) REFERENCES Courses(id)
);

CREATE TABLE CompletedCourses (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    StudentID NUMBER NOT NULL,
    CourseID NUMBER NOT NULL,
    completion_date DATE DEFAULT SYSDATE,
    final_grade NUMBER,
    CONSTRAINT fk_completed_student FOREIGN KEY (StudentID) REFERENCES Students(id),
    CONSTRAINT fk_completed_course FOREIGN KEY (CourseID) REFERENCES Courses(id),
    CONSTRAINT uq_student_completed_course UNIQUE (StudentID, CourseID)
);

CREATE TABLE Register (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    course_id NUMBER NOT NULL,
    CONSTRAINT fk_reg_student FOREIGN KEY (student_id) REFERENCES Students(id),
    CONSTRAINT fk_reg_course FOREIGN KEY (course_id) REFERENCES Courses(id),
    CONSTRAINT uq_student_course UNIQUE (student_id, course_id)
);

CREATE TABLE Exams (
    id NUMBER PRIMARY KEY,
    course_id NUMBER NOT NULL,
    exam_date DATE NOT NULL,
    exam_type VARCHAR2(20),
    CONSTRAINT fk_exam_course FOREIGN KEY (course_id) REFERENCES Courses(id)
);

CREATE TABLE ExamResults (
    id NUMBER PRIMARY KEY,
    registration_id NUMBER NOT NULL,
    numeric_score NUMBER,
    grade VARCHAR2(2),
    status VARCHAR2(20),
    CONSTRAINT fk_examresults_register FOREIGN KEY (registration_id) REFERENCES Register(id)
);

CREATE TABLE AuditTrail (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR2(50),
    operation VARCHAR2(10),
    old_data CLOB,
    new_data CLOB,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Warnings (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    warning_reason VARCHAR2(255) NOT NULL,
    warning_date DATE DEFAULT SYSDATE,
    CONSTRAINT fk_student FOREIGN KEY (student_id) REFERENCES Students(id)
);

CREATE TABLE DBUserCreationLog (
    log_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    new_username VARCHAR2(50),
    created_by VARCHAR2(50),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

INSERT INTO Students(id, name, academic_status) VALUES (1, 'Salma', 'Active');
INSERT INTO Students(id, name, academic_status) VALUES (2, 'Fatma', 'Active');
INSERT INTO Students(id, name, academic_status) VALUES (3, 'Marina', 'Active');
INSERT INTO Students(id, name, academic_status) VALUES (4, 'Mariam', 'Active');
INSERT INTO Students(id, name, academic_status) VALUES (5, 'Shahd', 'Active');
INSERT INTO Students(id, name, academic_status) VALUES (6, 'Hada', 'Active');

INSERT INTO Professors (id, name, department) VALUES (101, 'Dr. Ahmed', 'Computer Science');
INSERT INTO Professors (id, name, department) VALUES (102, 'Dr. Mona', 'Mathematics');

INSERT INTO Courses (id, name, professor_id, credit_hours, prerequisite) VALUES (1, 'DB1', 101, 3, NULL);
INSERT INTO Courses (id, name, professor_id, credit_hours, prerequisite) VALUES (2, 'DB2', 102, 3, 1);

INSERT INTO CompletedCourses (StudentID, CourseID, final_grade) VALUES (1, 1, 85);
INSERT INTO CompletedCourses (StudentID, CourseID, final_grade) VALUES (2, 1, 90);
INSERT INTO CompletedCourses (StudentID, CourseID, final_grade) VALUES (4, 1, 78);

INSERT INTO Register (student_id, course_id) VALUES (1, 2);
INSERT INTO Register (student_id, course_id) VALUES (2, 1);
INSERT INTO Register (student_id, course_id) VALUES (4, 2);
INSERT INTO Register (student_id, course_id) VALUES (4, 1);
INSERT INTO Register (student_id, course_id) VALUES (5, 1);
INSERT INTO Register (student_id, course_id) VALUES (3, 1);

INSERT INTO Exams (id, course_id, exam_date, exam_type) VALUES (1, 1, TO_DATE('2025-01-15', 'YYYY-MM-DD'), 'Midterm');
INSERT INTO Exams (id, course_id, exam_date, exam_type) VALUES (2, 1, TO_DATE('2025-02-20', 'YYYY-MM-DD'), 'Final');
INSERT INTO Exams (id, course_id, exam_date, exam_type) VALUES (3, 2, TO_DATE('2025-01-18', 'YYYY-MM-DD'), 'Midterm');
INSERT INTO Exams (id, course_id, exam_date, exam_type) VALUES (4, 2, TO_DATE('2025-02-25', 'YYYY-MM-DD'), 'Final');

INSERT INTO ExamResults (id, registration_id, numeric_score, grade, status) VALUES (1, 1, 92, NULL, NULL);
INSERT INTO ExamResults (id, registration_id, numeric_score, grade, status) VALUES (2, 2, 85, NULL, NULL);
INSERT INTO ExamResults (id, registration_id, numeric_score, grade, status) VALUES (3, 3, 75, NULL, NULL);
INSERT INTO ExamResults (id, registration_id, numeric_score, grade, status) VALUES (4, 4, 55, NULL, NULL);
INSERT INTO ExamResults (id, registration_id, numeric_score, grade, status) VALUES (5, 5, 50, NULL, NULL);

COMMIT;

CREATE SEQUENCE warnings_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE audit_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE register_seq START WITH 100 INCREMENT BY 1 NOCACHE NOCYCLE;

CREATE OR REPLACE PROCEDURE LogNewUser(p_new_username IN VARCHAR2)
IS
    v_created_by VARCHAR2(50);
BEGIN
    v_created_by := SYS_CONTEXT('USERENV', 'SESSION_USER');
    INSERT INTO DBUserCreationLog(new_username, created_by) VALUES (p_new_username, v_created_by);
    COMMIT;
END;
/

CREATE OR REPLACE TRIGGER CheckPrerequisite
BEFORE INSERT ON Register
FOR EACH ROW
DECLARE
    v_prereq NUMBER;
    v_count NUMBER;
    v_status VARCHAR2(20);
BEGIN
    SELECT academic_status INTO v_status FROM Students WHERE id = :NEW.student_id;
    
    IF v_status = 'Suspended' THEN
        RAISE_APPLICATION_ERROR(-20003, 'Registration denied: student is suspended');
    END IF;
    
    SELECT prerequisite INTO v_prereq FROM Courses WHERE id = :NEW.course_id;
    
    IF v_prereq IS NOT NULL THEN
        SELECT COUNT(*) INTO v_count FROM CompletedCourses 
        WHERE StudentID = :NEW.student_id AND CourseID = v_prereq;
        
        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Registration denied: prerequisite course not completed');
        END IF;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'Course or Student not found');
END;
/

CREATE OR REPLACE PROCEDURE CalculateGrade(p_exam_result_id IN NUMBER)
IS
    v_numeric_score NUMBER;
    v_grade VARCHAR2(2);
    v_status VARCHAR2(10);
BEGIN
    SELECT numeric_score INTO v_numeric_score FROM ExamResults WHERE id = p_exam_result_id;
    
    IF v_numeric_score IS NULL THEN
        RAISE_APPLICATION_ERROR(-20050, 'No numeric score found for this exam result');
    END IF;
   
    IF v_numeric_score >= 90 THEN
        v_grade := 'A'; v_status := 'Pass';
    ELSIF v_numeric_score >= 80 THEN
        v_grade := 'B'; v_status := 'Pass';
    ELSIF v_numeric_score >= 70 THEN
        v_grade := 'C'; v_status := 'Pass';
    ELSIF v_numeric_score >= 60 THEN
        v_grade := 'D'; v_status := 'Pass';
    ELSE
        v_grade := 'F'; v_status := 'Fail';
    END IF;

    UPDATE ExamResults SET grade = v_grade, status = v_status WHERE id = p_exam_result_id;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20051, 'Exam result ID not found');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20052, 'Error calculating grade: ' || SQLERRM);
END CalculateGrade;
/

CREATE OR REPLACE PROCEDURE issue_automatic_warnings
IS
    v_warnings_issued NUMBER := 0;
    v_exists NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Automated Warning Issuance Started');

    FOR rec IN (
        SELECT r.student_id, COUNT(*) AS fail_count
        FROM ExamResults er
        JOIN Register r ON er.registration_id = r.id
        WHERE er.status = 'Fail'
        GROUP BY r.student_id
        HAVING COUNT(*) >= 2
    ) LOOP

        SELECT COUNT(*)
        INTO v_exists
        FROM Warnings w
        WHERE w.student_id = rec.student_id
          AND w.warning_reason LIKE 'Failed%courses'
          AND w.warning_date >= SYSDATE - 30;

        IF v_exists = 0 THEN
            INSERT INTO Warnings(student_id, warning_reason, warning_date)
            VALUES (
                rec.student_id,
                'Failed ' || rec.fail_count || ' courses',
                SYSDATE
            );
            v_warnings_issued := v_warnings_issued + 1;
        END IF;

    END LOOP;

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Total Warnings Issued: ' || v_warnings_issued);
    DBMS_OUTPUT.PUT_LINE('Procedure Completed Successfully');

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
        RAISE_APPLICATION_ERROR(-20010,
            'Error in issue_automatic_warnings: ' || SQLERRM);
END issue_automatic_warnings;
/


CREATE OR REPLACE TRIGGER trg_register_audit_insert
BEFORE INSERT ON Register
FOR EACH ROW
DECLARE
    v_new_data CLOB;
BEGIN
    v_new_data := '{"student_id":' || :NEW.student_id || ',"course_id":' || :NEW.course_id || '}';
    INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp)
    VALUES ('Register', 'INSERT', NULL, v_new_data, SYSTIMESTAMP);
END;
/

CREATE OR REPLACE TRIGGER trg_register_audit_delete
BEFORE DELETE ON Register
FOR EACH ROW
DECLARE
    v_old_data CLOB;
BEGIN
    v_old_data := '{"student_id":' || :OLD.student_id || ',"course_id":' || :OLD.course_id || '}';
    INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp)
    VALUES ('Register', 'DELETE', v_old_data, NULL, SYSTIMESTAMP);
END;
/

CREATE OR REPLACE TRIGGER trg_students_audit_update
BEFORE UPDATE ON Students
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    v_old_data := '{"id":' || :OLD.id || ',"name":"' || :OLD.name || '","academic_status":"' || :OLD.academic_status || '","total_credits":' || :OLD.total_credits || '}';
    v_new_data := '{"id":' || :NEW.id || ',"name":"' || :NEW.name || '","academic_status":"' || :NEW.academic_status || '","total_credits":' || :NEW.total_credits || '}';
    INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp)
    VALUES ('Students', 'UPDATE', v_old_data, v_new_data, SYSTIMESTAMP);
END;
/

CREATE OR REPLACE PROCEDURE suspend_students_based_on_warnings
IS
    v_suspended_count NUMBER := 0;
BEGIN
    FOR rec IN (
        SELECT s.id AS student_id, s.name, s.academic_status AS old_status, COUNT(w.id) as warning_count
        FROM Students s
        JOIN Warnings w ON w.student_id = s.id
        WHERE s.academic_status != 'Suspended'
        GROUP BY s.id, s.name, s.academic_status
        HAVING COUNT(w.id) >= 3
    ) LOOP
        UPDATE Students SET academic_status = 'Suspended' WHERE id = rec.student_id;
        
        DBMS_OUTPUT.PUT_LINE('Student ID ' || rec.student_id || ' (' || rec.name || ') suspended. Warnings: ' || rec.warning_count);
        v_suspended_count := v_suspended_count + 1;
    END LOOP;
    
    COMMIT;
    
    IF v_suspended_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('No students met suspension criteria (3+ warnings).');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Total students suspended: ' || v_suspended_count);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RAISE_APPLICATION_ERROR(-20020, 'Error suspending students: ' || SQLERRM);
END;
/

CREATE OR REPLACE FUNCTION calculate_student_gpa(p_student_id IN NUMBER) RETURN NUMBER
IS
    v_total_points NUMBER := 0;
    v_total_credits NUMBER := 0;
    v_gpa NUMBER := 0;
BEGIN
    FOR rec IN (
        SELECT er.grade, c.credit_hours
        FROM ExamResults er
        JOIN Register r ON er.registration_id = r.id
        JOIN Courses c ON r.course_id = c.id
        WHERE r.student_id = p_student_id AND er.grade IS NOT NULL
    ) LOOP
        v_total_credits := v_total_credits + rec.credit_hours;
        v_total_points := v_total_points +
        CASE rec.grade
            WHEN 'A' THEN 4 * rec.credit_hours
            WHEN 'B' THEN 3 * rec.credit_hours
            WHEN 'C' THEN 2 * rec.credit_hours
            WHEN 'D' THEN 1 * rec.credit_hours
            WHEN 'F' THEN 0
            ELSE 0
        END;
    END LOOP;

    IF v_total_credits = 0 THEN
        RETURN 0;
    END IF;

    v_gpa := v_total_points / v_total_credits;
    RETURN ROUND(v_gpa, 2);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20030, 'Error calculating GPA: ' || SQLERRM);
END calculate_student_gpa;
/

CREATE OR REPLACE TRIGGER trg_authorize_grade_update
BEFORE UPDATE OF grade ON ExamResults
FOR EACH ROW
DECLARE
    v_user VARCHAR2(50);
    v_calling_proc VARCHAR2(100);
BEGIN
    v_user := SYS_CONTEXT('USERENV', 'SESSION_USER');
    
    BEGIN
        SELECT object_name INTO v_calling_proc 
        FROM user_procedures 
        WHERE object_name = 'CALCULATEGRADE';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_calling_proc := NULL;
    END;
    
    IF v_user NOT IN ('ADMIN', 'SYS', 'SYSTEM', 'MANGER', 'MANAGER') 
       AND v_user NOT LIKE 'PROFESSOR%' THEN
        RAISE_APPLICATION_ERROR(-20040, 'Unauthorized user cannot modify exam grades');
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE display_exam_schedule(p_course_id IN NUMBER)
IS
    v_course_name VARCHAR2(100);
    v_exam_count NUMBER := 0;
BEGIN
    SELECT name INTO v_course_name FROM Courses WHERE id = p_course_id;
    
    DBMS_OUTPUT.PUT_LINE('====================================================');
    DBMS_OUTPUT.PUT_LINE('Exam Schedule for Course: ' || v_course_name);
    DBMS_OUTPUT.PUT_LINE('====================================================');
    
    FOR exam_rec IN (
        SELECT exam_date, exam_type
        FROM Exams
        WHERE course_id = p_course_id
        ORDER BY exam_date
    ) LOOP
        v_exam_count := v_exam_count + 1;
        DBMS_OUTPUT.PUT_LINE('Exam Type: ' || RPAD(exam_rec.exam_type, 15) || 
                           ' | Date: ' || TO_CHAR(exam_rec.exam_date, 'DD-MON-YYYY'));
    END LOOP;
    
    IF v_exam_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('No exams are currently scheduled for this course.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('====================================================');
        DBMS_OUTPUT.PUT_LINE('Total Exams Scheduled: ' || v_exam_count);
    END IF;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: Course ID ' || p_course_id || ' not found.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END display_exam_schedule;
/

CREATE OR REPLACE PROCEDURE update_multiple_grades(
    p_exam_ids IN SYS.ODCINUMBERLIST,
    p_grades IN SYS.ODCIVARCHAR2LIST
)
IS
    v_updated_count NUMBER := 0;
BEGIN
    IF p_exam_ids.COUNT != p_grades.COUNT THEN
        RAISE_APPLICATION_ERROR(-20060, 'Number of exam IDs must match number of grades');
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('Starting multi-exam grade update transaction...');
    DBMS_OUTPUT.PUT_LINE('====================================================');
    
    FOR i IN 1..p_exam_ids.COUNT LOOP
        UPDATE ExamResults 
        SET grade = p_grades(i),
            status = CASE 
                WHEN p_grades(i) IN ('A', 'B', 'C', 'D') THEN 'Pass'
                ELSE 'Fail'
            END
        WHERE id = p_exam_ids(i);
        
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20061, 'Exam Result ID ' || p_exam_ids(i) || ' not found');
        END IF;
        
        DBMS_OUTPUT.PUT_LINE('Updated Exam Result ID ' || p_exam_ids(i) || ' to grade: ' || p_grades(i));
        v_updated_count := v_updated_count + 1;
    END LOOP;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('====================================================');
    DBMS_OUTPUT.PUT_LINE('Transaction completed successfully!');
    DBMS_OUTPUT.PUT_LINE('Total grades updated: ' || v_updated_count);
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('====================================================');
        DBMS_OUTPUT.PUT_LINE('ERROR: Transaction rolled back!');
        DBMS_OUTPUT.PUT_LINE('Error Details: ' || SQLERRM);
        RAISE;
END update_multiple_grades;
/

SET SERVEROUTPUT ON SIZE UNLIMITED;
SET LINESIZE 200;
SET PAGESIZE 100;

PROMPT ====================================================
PROMPT           COMPLETE TEST SUITE
PROMPT           University Database System
PROMPT ====================================================
PROMPT;

PROMPT ====================================================
PROMPT TEST 1: Check All Tables Created Successfully
PROMPT ====================================================
SELECT table_name 
FROM user_tables 
WHERE table_name IN ('STUDENTS', 'PROFESSORS', 'COURSES', 'COMPLETEDCOURSES', 
                     'REGISTER', 'EXAMS', 'EXAMRESULTS', 'AUDITTRAIL', 
                     'WARNINGS', 'DBUSERCREATIONLOG')
ORDER BY table_name;

PROMPT;
PROMPT ====================================================
PROMPT TEST 2: Verify Initial Data Insertion
PROMPT ====================================================
SELECT * FROM Students ORDER BY id;
SELECT * FROM Professors ORDER BY id;
SELECT * FROM Courses ORDER BY id;
SELECT * FROM Register ORDER BY id;

PROMPT;
PROMPT ====================================================
PROMPT TEST 3: Test Prerequisite Trigger (Should FAIL)
PROMPT ====================================================
BEGIN
    DBMS_OUTPUT.PUT_LINE('Attempting to register Student 6 (Hada) for Course 2 (DB2) without completing prerequisite...');
    INSERT INTO Register (student_id, course_id) VALUES (6, 2);
    DBMS_OUTPUT.PUT_LINE('ERROR: Trigger did not work - insertion should have been blocked!');
    ROLLBACK;
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -20001 THEN
            DBMS_OUTPUT.PUT_LINE('SUCCESS: Prerequisite Trigger worked correctly!');
            DBMS_OUTPUT.PUT_LINE('Error Message: ' || SQLERRM);
        ELSE
            DBMS_OUTPUT.PUT_LINE('FAILED: Different error occurred!');
            DBMS_OUTPUT.PUT_LINE('Error Code: ' || SQLCODE);
            DBMS_OUTPUT.PUT_LINE('Error Message: ' || SQLERRM);
        END IF;
        ROLLBACK;
END;
/

PROMPT;
PROMPT ====================================================
PROMPT TEST 4: Test CalculateGrade Function
PROMPT ====================================================
DECLARE
    v_grade VARCHAR2(2);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Testing Grade Calculation:');
    DBMS_OUTPUT.PUT_LINE('----------------------------');
    FOR i IN 1..5 LOOP
        v_grade := CalculateGrade(i);
        DBMS_OUTPUT.PUT_LINE('✓ Exam Result ID ' || i || ': Grade = ' || v_grade);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('----------------------------');
    DBMS_OUTPUT.PUT_LINE('✓ SUCCESS: All grades calculated!');
END;
/

PROMPT;
SELECT id, registration_id, numeric_score, grade, status FROM ExamResults ORDER BY id;

PROMPT;
PROMPT ====================================================
PROMPT TEST 5: Test Automatic Warning System
PROMPT ====================================================
EXEC issue_automatic_warnings;

PROMPT;
SELECT w.id, w.student_id, s.name, w.warning_reason, TO_CHAR(w.warning_date, 'DD-MON-YYYY') as warning_date FROM Warnings w JOIN Students s ON w.student_id = s.id ORDER BY w.id;

PROMPT;
PROMPT ====================================================
PROMPT TEST 6: Test GPA Calculation
PROMPT ====================================================
DECLARE
    v_gpa NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Student GPA Report:');
    DBMS_OUTPUT.PUT_LINE('----------------------------');
    FOR rec IN (SELECT id, name FROM Students ORDER BY id) LOOP
        v_gpa := calculate_student_gpa(rec.id);
        IF v_gpa > 0 THEN
            DBMS_OUTPUT.PUT_LINE('Student: ' || RPAD(rec.name, 10) || ' => GPA: ' || v_gpa);
        ELSE
            DBMS_OUTPUT.PUT_LINE('Student: ' || RPAD(rec.name, 10) || ' => No grades yet');
        END IF;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('----------------------------');
END;
/

PROMPT;
PROMPT ====================================================
PROMPT TEST 7: Test Student Suspension
PROMPT ====================================================
PROMPT Adding 2 more warnings to Student 4...
INSERT INTO Warnings (student_id, warning_reason) VALUES (4, 'Low Attendance');
INSERT INTO Warnings (student_id, warning_reason) VALUES (4, 'Academic Misconduct');
COMMIT;

PROMPT;
SELECT 'Current Warnings for Student 4:' as Info, COUNT(*) as Total_Warnings FROM Warnings WHERE student_id = 4;

PROMPT;
PROMPT Executing suspension procedure...
EXEC suspend_students_based_on_warnings;

PROMPT;
SELECT id, name, academic_status FROM Students ORDER BY id;

PROMPT;
PROMPT ====================================================
PROMPT TEST 8: Test Audit Trail
PROMPT ====================================================
PROMPT Testing audit triggers by adding and removing registration...
INSERT INTO Register (student_id, course_id) VALUES (1, 1);
DELETE FROM Register WHERE student_id = 1 AND course_id = 1;

PROMPT;
SELECT id, table_name, operation, SUBSTR(old_data, 1, 60) as old_data, SUBSTR(new_data, 1, 60) as new_data, TO_CHAR(timestamp, 'DD-MON-YY HH24:MI:SS') as log_time FROM AuditTrail ORDER BY id DESC FETCH FIRST 10 ROWS ONLY;

PROMPT;
PROMPT ====================================================
PROMPT TEST 9: Course Performance Report
PROMPT ====================================================
DECLARE
    v_passed NUMBER := 0;
    v_failed NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Course Performance Report - DB1 (Course ID: 1)');
    DBMS_OUTPUT.PUT_LINE('===============================================');
    
    FOR rec IN (
        SELECT r.student_id, s.name, er.grade, er.status
        FROM Register r
        JOIN ExamResults er ON r.id = er.registration_id
        JOIN Students s ON r.student_id = s.id
        WHERE r.course_id = 1 AND er.grade IS NOT NULL
        ORDER BY r.student_id
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Student: ' || RPAD(rec.name, 10) || 
                           ' | Grade: ' || RPAD(rec.grade, 2) ||
                           ' | Status: ' || rec.status);
        
        IF rec.status = 'Pass' THEN
            v_passed := v_passed + 1;
        ELSE
            v_failed := v_failed + 1;
        END IF;
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('===============================================');
    DBMS_OUTPUT.PUT_LINE('Total Passed: ' || v_passed);
    DBMS_OUTPUT.PUT_LINE('Total Failed: ' || v_failed);
    IF (v_passed + v_failed) > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Pass Rate: ' || ROUND((v_passed / (v_passed + v_failed)) * 100, 1) || '%');
    END IF;
END;
/

PROMPT;
PROMPT ====================================================
PROMPT TEST 10: Test Exam Schedule Management
PROMPT ====================================================
EXEC display_exam_schedule(1);

PROMPT;
PROMPT ====================================================
PROMPT TEST 11: Multi-Exam Grade Update
PROMPT ====================================================
PROMPT Testing transaction with valid grades...
DECLARE
    v_exam_ids SYS.ODCINUMBERLIST := SYS.ODCINUMBERLIST(1, 2, 3);
    v_grades SYS.ODCIVARCHAR2LIST := SYS.ODCIVARCHAR2LIST('A', 'B', 'C');
BEGIN
    update_multiple_grades(v_exam_ids, v_grades);
END;
/

PROMPT;
SELECT id, registration_id, grade, status FROM ExamResults WHERE id IN (1, 2, 3);

PROMPT;
PROMPT Testing transaction with error (should rollback)...
DECLARE
    v_exam_ids SYS.ODCINUMBERLIST := SYS.ODCINUMBERLIST(1, 999, 3);
    v_grades SYS.ODCIVARCHAR2LIST := SYS.ODCIVARCHAR2LIST('F', 'D', 'C');
BEGIN
    update_multiple_grades(v_exam_ids, v_grades);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Expected error occurred - transaction rolled back successfully');
END;
/

PROMPT;
PROMPT ====================================================
PROMPT TEST 12: Test Suspended Student Registration Block
PROMPT ====================================================
BEGIN
    DBMS_OUTPUT.PUT_LINE('Attempting to register suspended student...');
    UPDATE Students SET academic_status = 'Suspended' WHERE id = 3;
    COMMIT;
    INSERT INTO Register (student_id, course_id) VALUES (3, 2);
    DBMS_OUTPUT.PUT_LINE('ERROR: Trigger did not work!');
    ROLLBACK;
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -20003 THEN
            DBMS_OUTPUT.PUT_LINE('SUCCESS: Suspended student cannot register!');
            DBMS_OUTPUT.PUT_LINE('Error Message: ' || SQLERRM);
        ELSE
            DBMS_OUTPUT.PUT_LINE('Different error: ' || SQLERRM);
        END IF;
        ROLLBACK;
END;
/

PROMPT;
PROMPT ====================================================
PROMPT TEST 13: Final System Summary
PROMPT ====================================================
SELECT 'Total Students' AS Metric, COUNT(*) AS Count FROM Students
UNION ALL
SELECT 'Active Students', COUNT(*) FROM Students WHERE academic_status = 'Active'
UNION ALL
SELECT 'Suspended Students', COUNT(*) FROM Students WHERE academic_status = 'Suspended'
UNION ALL
SELECT 'Total Courses', COUNT(*) FROM Courses
UNION ALL
SELECT 'Active Registrations', COUNT(*) FROM Register
UNION ALL
SELECT 'Completed Exams', COUNT(*) FROM ExamResults WHERE grade IS NOT NULL
UNION ALL
SELECT 'Students Passed', COUNT(*) FROM ExamResults WHERE status = 'Pass'
UNION ALL
SELECT 'Students Failed', COUNT(*) FROM ExamResults WHERE status = 'Fail'
UNION ALL
SELECT 'Total Warnings', COUNT(*) FROM Warnings
UNION ALL
SELECT 'Audit Records', COUNT(*) FROM AuditTrail;

PROMPT;
PROMPT ====================================================
PROMPT USER MANAGEMENT IMPLEMENTATION
PROMPT ====================================================
PROMPT;
PROMPT Step 1: Creating Manager User (Execute as SYSTEM):
PROMPT CREATE USER MANGER IDENTIFIED BY manager123;
PROMPT GRANT CONNECT, RESOURCE, CREATE SESSION, CREATE USER, ALTER USER TO MANGER;
PROMPT GRANT CREATE TABLE, CREATE PROCEDURE, CREATE TRIGGER TO MANGER;
PROMPT ALTER USER MANGER QUOTA UNLIMITED ON USERS;
PROMPT;
PROMPT Step 2: Manager Creates Two Users (Execute as MANGER):
PROMPT CREATE USER USER1 IDENTIFIED BY user1pass;
PROMPT GRANT CONNECT, RESOURCE, CREATE SESSION, CREATE TABLE TO USER1;
PROMPT ALTER USER USER1 QUOTA UNLIMITED ON USERS;
PROMPT EXEC LogNewUser('USER1');
PROMPT;
PROMPT CREATE USER USER2 IDENTIFIED BY user2pass;
PROMPT GRANT CONNECT, RESOURCE, CREATE SESSION, INSERT ANY TABLE TO USER2;
PROMPT ALTER USER USER2 QUOTA UNLIMITED ON USERS;
PROMPT EXEC LogNewUser('USER2');
PROMPT;
PROMPT Step 3: USER1 Creates Tables (Execute as USER1):
PROMPT CREATE TABLE Students (
PROMPT     id NUMBER PRIMARY KEY,
PROMPT     name VARCHAR2(50),
PROMPT     academic_status VARCHAR2(20)
PROMPT );
PROMPT;
PROMPT CREATE TABLE Courses (
PROMPT     id NUMBER PRIMARY KEY,
PROMPT     name VARCHAR2(100) NOT NULL,
PROMPT     credit_hours NUMBER
PROMPT );
PROMPT;
PROMPT Step 4: USER2 Inserts Data (Execute as USER2):
PROMPT INSERT INTO USER1.Students VALUES (1, 'Ahmed', 'Active');
PROMPT INSERT INTO USER1.Students VALUES (2, 'Sara', 'Active');
PROMPT INSERT INTO USER1.Students VALUES (3, 'Mohamed', 'Active');
PROMPT INSERT INTO USER1.Students VALUES (4, 'Nour', 'Active');
PROMPT INSERT INTO USER1.Students VALUES (5, 'Omar', 'Active');
PROMPT COMMIT;
PROMPT;
PROMPT Check DBUserCreationLog:
SELECT * FROM DBUserCreationLog;

PROMPT;
PROMPT ====================================================
PROMPT BLOCKER-WAITING DEMONSTRATION
PROMPT ====================================================
PROMPT;

PROMPT Creating blocker_session.sql...
SPOOL blocker_session.sql
SELECT 'SET SERVEROUTPUT ON;' FROM DUAL;
SELECT 'PROMPT ===== BLOCKER SESSION STARTED =====' FROM DUAL;
SELECT 'UPDATE Students SET academic_status = ''OnHold'' WHERE id = 2;' FROM DUAL;
SELECT 'PROMPT Row LOCKED for Student ID 2' FROM DUAL;
SELECT 'PROMPT;' FROM DUAL;
SELECT 'SELECT ''Blocker Session Info:'' as Info, sid, serial#, username, status FROM v$session WHERE sid = (SELECT sid FROM v$mystat WHERE rownum = 1);' FROM DUAL;
SELECT 'PROMPT;' FROM DUAL;
SELECT 'PROMPT Keeping lock for 30 seconds...' FROM DUAL;
SELECT 'EXEC DBMS_LOCK.SLEEP(30);' FROM DUAL;
SELECT 'COMMIT;' FROM DUAL;
SELECT 'PROMPT BLOCKER COMMITTED - Lock Released' FROM DUAL;
SPOOL OFF

PROMPT Creating waiting_session.sql...
SPOOL waiting_session.sql
SELECT 'SET SERVEROUTPUT ON;' FROM DUAL;
SELECT 'PROMPT ===== WAITING SESSION STARTED =====' FROM DUAL;
SELECT 'PROMPT Attempting to update Student ID 2...' FROM DUAL;
SELECT 'PROMPT This will WAIT for blocker session to release lock' FROM DUAL;
SELECT 'UPDATE Students SET name = ''Updated_Name'' WHERE id = 2;' FROM DUAL;
SELECT 'PROMPT Update completed after lock released' FROM DUAL;
SELECT 'COMMIT;' FROM DUAL;
SELECT 'PROMPT WAITING SESSION COMPLETED' FROM DUAL;
SPOOL OFF

PROMPT Creating monitor_blocking.sql...
SPOOL monitor_blocking.sql
SELECT 'SET SERVEROUTPUT ON;' FROM DUAL;
SELECT 'SET LINESIZE 200;' FROM DUAL;
SELECT 'SET PAGESIZE 100;' FROM DUAL;
SELECT 'PROMPT ===== BLOCKING SESSIONS MONITOR =====' FROM DUAL;
SELECT 'PROMPT;' FROM DUAL;
SELECT 'PROMPT Current Locked Objects:' FROM DUAL;
SELECT 'SELECT s.sid, s.serial#, s.username, s.status, o.object_name, DECODE(l.locked_mode, 0, ''None'', 1, ''Null'', 2, ''Row-S'', 3, ''Row-X'', 4, ''Share'', 5, ''S/Row-X'', 6, ''Exclusive'', ''Unknown'') AS lock_mode FROM v$locked_object l JOIN v$session s ON l.session_id = s.sid JOIN dba_objects o ON l.object_id = o.object_id;' FROM DUAL;
SELECT 'PROMPT;' FROM DUAL;
SELECT 'PROMPT Sessions with Blocking:' FROM DUAL;
SELECT 'SELECT s.sid AS session_id, s.serial#, s.username, s.status, s.blocking_session, s.event, s.seconds_in_wait FROM v$session s WHERE s.blocking_session IS NOT NULL OR s.sid IN (SELECT blocking_session FROM v$session WHERE blocking_session IS NOT NULL);' FROM DUAL;
SELECT 'PROMPT;' FROM DUAL;
SELECT 'PROMPT Detailed Blocker-Waiter Relationship:' FROM DUAL;
SELECT 'SELECT DISTINCT s1.sid || '','' || s1.serial# AS blocker_session, s1.username AS blocker_user, s1.status AS blocker_status, s2.sid || '','' || s2.serial# AS waiting_session, s2.username AS waiting_user, s2.event AS wait_event, s2.seconds_in_wait FROM v$session s1 JOIN v$session s2 ON s1.sid = s2.blocking_session WHERE s2.blocking_session IS NOT NULL;' FROM DUAL;
SPOOL OFF

PROMPT;
PROMPT ====================================================
PROMPT EXECUTION INSTRUCTIONS:
PROMPT ====================================================
PROMPT;
PROMPT 1. Open THREE separate SQL*Plus windows
PROMPT 2. In Window 1: Run @blocker_session.sql
PROMPT 3. In Window 2: Wait 2 seconds then run @waiting_session.sql
PROMPT 4. In Window 3: Run @monitor_blocking.sql multiple times
PROMPT;
PROMPT After 30 seconds, the blocker will commit and waiting session will complete
PROMPT;

PROMPT ====================================================
PROMPT Alternative: Single Session Demonstration
PROMPT ====================================================
PROMPT;

BEGIN
    DBMS_OUTPUT.PUT_LINE('====================================================');
    DBMS_OUTPUT.PUT_LINE('SIMULATED BLOCKER-WAITING SCENARIO');
    DBMS_OUTPUT.PUT_LINE('====================================================');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('In a real multi-session scenario:');
    DBMS_OUTPUT.PUT_LINE('1. Session 1 locks Student ID 2 with UPDATE');
    DBMS_OUTPUT.PUT_LINE('2. Session 2 tries to UPDATE same row and WAITS');
    DBMS_OUTPUT.PUT_LINE('3. Session 3 monitors and identifies:');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   Blocker Session: SID=123, SERIAL#=456');
    DBMS_OUTPUT.PUT_LINE('   Waiting Session: SID=789, SERIAL#=012');
    DBMS_OUTPUT.PUT_LINE('   Locked Object: STUDENTS table');
    DBMS_OUTPUT.PUT_LINE('   Wait Event: enq: TX - row lock contention');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('4. When Session 1 commits, Session 2 proceeds');
    DBMS_OUTPUT.PUT_LINE('====================================================');
END;
/

PROMPT;
PROMPT Current Session Information:
SELECT sid, serial#, username, status, blocking_session
FROM v$session 
WHERE username = USER;

PROMPT;
PROMPT To view all current locks in database:
SELECT 
    s.sid,
    s.serial#,
    s.username,
    o.object_name,
    DECODE(l.locked_mode, 
        0, 'None',
        1, 'Null',
        2, 'Row-S',
        3, 'Row-X',
        4, 'Share',
        5, 'S/Row-X',
        6, 'Exclusive',
        'Unknown') AS lock_mode
FROM v$locked_object l
JOIN v$session s ON l.session_id = s.sid
JOIN dba_objects o ON l.object_id = o.object_id;

PROMPT;
PROMPT ====================================================
PROMPT ALL TESTS COMPLETED SUCCESSFULLY!
PROMPT ====================================================
PROMPT;
PROMPT Database is ready for production use!
PROMPT ====================================================
